#!/bin/bash

#checks if user exists
# USERNAME
check_user() {
    local USERNAME=$1

    echo "" 1>&2
    /bin/egrep -i "^${USERNAME}" /etc/passwd
    if [ $? -eq 0 ]; then
       echo "User $USERNAME exists" 1>&2
       true
    else
       echo "User $USERNAME does not exists" 1>&2
       false
    fi
}

#create user
# USER, HOME_DIR, DESCRIPTION
create_user() {
    local USER=$1
    local HOME_DIR=$2
    local DESCRIPTION=$3

    if ! check_user $USER ; then
        set +e
        adduser --disabled-password --disabled-login --home $HOME_DIR --gecos "$DESCRIPTION" $USER
        ERRNO=$?
        set -e

        # 0=ok
        if [ "$ERRNO" != 0 ]; then
            echo "adduser returned $ERRNO" 1>&2
            echo "There was an error while adding $USER" 1>&2
            echo "" 1>&2
            db_stop
            exit 1
        fi
    fi
}

#stop initd script
# INITD
stop_initd() {
    local INITD=$1

    if [ -f /etc/init.d/$INITD ]; then
        echo "" 1>&2
        echo "Stopping running $INITD ..." 1>&2

        CMD="/etc/init.d/$INITD stop"

        set +e
        $CMD
        ERRNO=$?
        set -e

        # 0=ok
        if [ "$ERRNO" != 0 ]; then
            echo "${CMD/ */} returned $ERRNO" 1>&2
            echo "There was an error while stopping $INITD" 1>&2
            echo "" 1>&2
            db_stop
            exit 1
        fi
    fi
}

#install or upgrade an initd script
# APP_SCRIPTS_DIR, INITD_SCRIPT
install_or_upgrade_initd() {
    local APP_SCRIPTS_DIR=$1
    local INITD_SCRIPT=$2

    local UPGRADE=false
    if [ -f /etc/init.d/$INITD_SCRIPT ]; then
        UPGRADE=true
    fi

    echo "" 1>&2
    if [ $UPGRADE = true ]; then
        cp $APP_SCRIPTS_DIR/$INITD_SCRIPT /etc/init.d
        echo "Initd script $INITD_SCRIPT upgraded." 1>&2
    else
        cp $APP_SCRIPTS_DIR/$INITD_SCRIPT /etc/init.d
        update-rc.d $INITD_SCRIPT defaults 91
        echo "Initd script $INITD_SCRIPT installed." 1>&2
    fi
}

#remove initd script
# INITD_SCRIPT
remove_initd() {
    local INITD_SCRIPT=$1

    if [ -f /etc/init.d/$INITD_SCRIPT ]; then
        rm /etc/init.d/$INITD_SCRIPT
        update-rc.d $INITD_SCRIPT remove
        echo "" 1>&2
        echo "Initd script $INITD_SCRIPT removed." 1>&2
    fi
}

#download and unzip a tar.gz file
# APP_NAME, APP_VERSION, APP_BASE_URL, APP_FILE_URL, APP_DOWNLOAD_DIR, APP_INST_DIR
download_and_unzip() {
    local APP_NAME=$1
    local APP_VERSION=$2
    local APP_BASE_URL=$3
    local APP_FILE_URL=$4
    local APP_DOWNLOAD_DIR=$5
    local APP_INST_DIR=$6

    echo "" 1>&2
    echo "Downloading $APP_NAME $APP_VERSION ..." 1>&2

    APP_URL=$APP_BASE_URL/$APP_FILE_URL
    CMD="wget -nc -P $APP_DOWNLOAD_DIR $APP_URL"

    set +e
    $CMD
    ERRNO=$?
    set -e

    # 0=ok
    if [ "$ERRNO" != 0 ]; then
      echo "${CMD/ */} returned $ERRNO" 1>&2
      echo "There was an error during downloading $APP_URL" 1>&2
      echo "" 1>&2
      db_stop
      exit 1
    fi

    echo "Unzipping $APP_FILE_URL ..." 1>&2

    cd $APP_DOWNLOAD_DIR

    # x extract,f file,g gzip
    CMD="tar -xzf $APP_FILE_URL"

    set +e
    $CMD
    ERRNO=$?
    set -e

    # 0=ok
    if [ "$ERRNO" != 0 ]; then
      echo "${CMD/ */} returned $ERRNO" 1>&2
      echo "There was an error during unzipping $APP_FILE_URL" 1>&2
      echo "" 1>&2
      db_stop
      exit 1
    fi

    mkdir -p $APP_INST_DIR

    # remove end string ".tar.gz"
    APP_UNZIPPED=${APP_FILE_URL//".tar.gz"}

    #copy only when the SOURCE file is newer than the destination file or when the destination file is missing
    cp -ur $APP_UNZIPPED/* $APP_INST_DIR

    #we remove the unzipped directory even if some files weren't moved because already existing in the target directory
    rmdir --ignore-fail-on-non-empty $APP_UNZIPPED

    echo "$APP_FILE_URL extracted and moved (w/o overwriting existing files) to $APP_INST_DIR" 1>&2
}

#configure cronjob
# CRON, CRON_DESCRIPTION
configure_cronjob() {
    local CRON=$1
    local CRON_DESCRIPTION=$2

    echo "" 1>&2
    echo "Installing cron job for $CRON_DESCRIPTION ..." 1>&2

    local TMP_CRON_FILE=/tmp/current_jobs

    set +e
    #write out current cron jobs
    crontab -l > $TMP_CRON_FILE

    #echo new cron job into cron file
    echo "$CRON" >> $TMP_CRON_FILE

    #install the new cron job
    CMD="crontab $TMP_CRON_FILE"
    $CMD
    ERRNO=$?
    set -e

    # 0=ok
    if [ "$ERRNO" != 0 -a "$ERRNO" != 100 ]; then
        echo "${CMD/ */} returned $ERRNO" 1>&2
        echo "There was an error during the installation of the cron job for $CRON_DESCRIPTION" 1>&2
        echo "" 1>&2
        db_stop
        exit 1
    else
        rm $TMP_CRON_FILE
    fi
}

#remove cronjob
# CRON, CRON_DESCRIPTION
remove_cronjob() {
    local CRON=$1
    local CRON_DESCRIPTION=$2

    echo "" 1>&2
    echo "Removing cron job for $CRON_DESCRIPTION ..." 1>&2

    local TMP_CRON_FILE=/tmp/current_jobs

    set +e
    #write out current cron jobs
    crontab -l > $TMP_CRON_FILE

    #remove previous cron job if is there
    grep -v $CRON $TMP_CRON_FILE > $TMP_CRON_FILE

    #install new cron job
    CMD="crontab $TMP_CRON_FILE"
    $CMD
    ERRNO=$?
    set -e

    # 0=ok
    if [ "$ERRNO" != 0 -a "$ERRNO" != 100 ]; then
        echo "${CMD/ */} returned $ERRNO" 1>&2
        echo "There was an error during the removal of the cronjob for $CRON_DESCRIPTION" 1>&2
        echo "" 1>&2
        db_stop
        exit 1
    else
        rm $TMP_CRON_FILE
    fi
}


# safe execute cmd
# stops the installation if the returned value is not equal to the one passed
#safe_exec() {
#    local CMD=$1
#    local RETURN=$2
#
#    set +e
#    set -x
#    #TODO doesn't work
#
#    echo "$CMD" | sh
#    ERRNO=$?
#    set +x
#    set -e
#
#    # if return value different from expected
#    if [ "$ERRNO" != $RETURN ]; then
#       echo "${CMD/ */} returned $ERRNO" 1>&2
#       db_stop
#       exit 1
#    fi
#}
