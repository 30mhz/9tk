# Copyright (C) 2011, 2012 9apps B.V.
# 
# This file is part of 9apps Tools.
# 
# 9apps Tools is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# 9apps Tools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with 9apps Tools. If not, see <http://www.gnu.org/licenses/>.


import os, sys, subprocess
import json
from urllib2 import urlopen

from time import gmtime,strftime,time

from boto.ec2.connection import EC2Connection
from boto.ec2.regioninfo import RegionInfo

# expiration in the future, calculated like this
DAYS = 24 * 60 * 60

# Ubuntu 12.04 uses recent kernels (/dev/xvdf), EC2 not yet (/dev/sdf)
def DEVICE(device):
	return device.replace('/s', '/xv')

class Backup:
	# config is something like
	# {
	#     "schedule" : ["hourly", "daily", "weekly", "monthly"],
	#     "expiration" : [1, 7, 28, 365],
	#     "hourly" : "15 */2 * * *",
	#     "daily" : "@daily",
	#     "weekly" : "@weekly",
	#     "monthly" : "@monthly"
	# }
	def __init__(self, key, access, name, config = {}):
		try:
			url = "http://169.254.169.254/latest/meta-data/"

			region = urlopen(url + "placement/availability-zone/").read()[:-1]
		except:
			sys.exit("We should be getting instance meta-data here...")

		endpoint = "ec2.{0}.amazonaws.com".format(region)
		region_info = RegionInfo(name=region, endpoint=endpoint)
		self.ec2 = EC2Connection(key, access, region=region_info)

		self.name = name
		self.instance_id = urlopen(url + "instance-id").read()

		self.config = config

	def __del__(self):
		pass

	# set up cron for the user executing us
	def setup(self):
		cmd = "{0} {1}".format(sys.executable, os.path.abspath(__file__))

		try:
			f = open("/etc/cron.d/9apps-backup", "w")

			if 'hourly' not in self.config:
				hourly = "0 * * * *"
			else:
				hourly = self.config['hourly']

			if 'daily' not in self.config:
				daily = "0 0 * * *"
			else:
				daily = self.config['daily']

			if 'weekly' not in self.config:
				weekly = "0 0 * * 0"
			else:
				weekly = self.config['weekly']

			if 'monthly' not in self.config:
				monthly = "0 0 1 * *"
			else:
				monthly = self.config['monthly']

			f.write("# this file is auto-generated by 9apps' backup\n")
			f.write("# script. (see github.com/9apps for details.)\n")
			f.write("#\n")
			f.write("# generated with 'python backup.py setup'\n")
			f.write("{0} root {1} all hourly > /dev/null 2>&1\n".format(hourly, cmd))
			f.write("{0} root {1} all daily > /dev/null 2>&1\n".format(daily, cmd))
			f.write("{0} root {1} all weekly > /dev/null 2>&1\n".format(weekly, cmd))
			f.write("{0} root {1} all monthly > /dev/null 2>&1\n".format(monthly, cmd))
			f.write("{0} root {1} purge \"`date +\"%Y-%m-%d %H:%M:%S\"`\"> /dev/null 2>&1\n".format(monthly, cmd))
		finally:
			f.close()

	def _expires(self, expiration = 'hourly'):
		form = "%Y-%m-%d %H:%M:%S"

		i = self.config['schedule'].index(expiration)
		schedule = int(self.config['expiration'][i])

		return strftime(form, gmtime(time() + schedule * DAYS))

	def volume(self, device = "/dev/sdf", expiration = "daily"):
		# first get the mountpoint (requires some energy, but we can...)
		df = subprocess.Popen(["/bin/df", DEVICE(device)],
							stdout=subprocess.PIPE)
		dummy, size, used, available, percent, mountpoint = \
							df.communicate()[0].split("\n")[1].split()

		# if we have the device (/dev/xvdf) just don't do anything anymore
		mapping = self.ec2.get_instance_attribute(self.instance_id,
							'blockDeviceMapping')['blockDeviceMapping']
		volume_id = mapping[device].volume_id
		try:
			os.system("/usr/sbin/xfs_freeze -f {0}".format(mountpoint))
			snapshot = self.ec2.create_snapshot(volume_id,
					"Backup of {0} - for {1}{2} - expires {3}".format(
									volume_id, self.name, mountpoint,
									self._expires(expiration)))
			params = { "Name" : self.name,
									"Expires" : self._expires(expiration) }
			self.ec2.create_tags([snapshot.id], params)
		finally:
			os.system("/usr/sbin/xfs_freeze -u {0}".format(mountpoint))

	def _get_mapping(self, root = False):
		mapping = self.ec2.get_instance_attribute(self.instance_id,
								'blockDeviceMapping')['blockDeviceMapping']

		# exclude root device
		if not root:
			root = self.ec2.get_instance_attribute(self.instance_id,
							'rootDeviceName')['rootDeviceName']
			del mapping[root]

		return mapping

	def all(self, expiration = "daily"):
		mapping = self._get_mapping()
		for device in mapping:
			self.volume(device, expiration)

	def _get_snapshots(self, expiration = 'none'):
		params = { "tag:Name" : self.name }
		snapshots = self.ec2.get_all_snapshots(filters=params)

		expired = []
		if expiration != 'none':
			for snapshot in snapshots:
				if snapshot.tags['Expires'] < expiration:
					expired.append(snapshot)

		return expired

	def _delete(self, snapshot):
		self.ec2.delete_snapshot(snapshot)

	# purges past their expiration date, or 'all' (by default it does nothing)
	def purge(self, expiration = 'none'):
		snapshots = self._get_snapshots(expiration)
		for snapshot in snapshots:
			print "deleting snapshot {0}".format(snapshot.id)
			self._delete(snapshot.id)

if __name__ == '__main__':
	userdata = json.load(urlopen("http://169.254.169.254/latest/user-data/"))

	backup = Backup(
				userdata['access_key_id'],
				userdata['secret_access_key'],
				"{0}.{1}.{2}".format(userdata['name'],
							userdata['environment'],
							userdata['domain']),
				userdata['backups'])
	
	print (getattr(backup, sys.argv[1])(*sys.argv[2:]))
